#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
Calculate exon skipping frequency from results of scan_exon_skipping.py.
Output 2 files: .es.bed; .es.group

Rational:
For exon skipping events illustrated below, 
=====---1>----===========----->---=======
    _                             _  
     \__2________________________/
let num() be number of junction reads supporting each splicing, 
the exon skipping frequency can be calculated by num(2)/(num(1)+num(2)), 
making the sum of frequency of both possible splicing events to 1.

For a complex exon skipping event:
=====---1>----===-----======-->---=======
    _                 _
     \__2____________/    
    _                             _  
     \__3________________________/

to make sum of all exon skipping frequency to be 1, frequency of each exon 
skipping event (in this case, 2 and 3) is calculated as num(skip)/sum_of_nums.

Since mRNAs are trancribed from 5' to 3' and proteins are translated in the 
same orientation, we take exon skipping events sharing same splice donor as 
a group (sum of freq to be 1).

Usage:
    python exon_skipping_freq.py -i <.exon_skipping> 
                                 -o <bed12> -g <grouping_log>
                                 
Input:
    -i  .exon_skipping file genereated by scan_exon_skipping.py.
    
Output:
    -o  BED12 format file documenting exon skipping event, 
        marking skipped exons. add 2 column as "sup_read" and "total_junc_read"
        score is the integer of frequency*1000
        name is transcript name + exonId, e.g. IMMRT10001038231_exon16_exon19
    -g  grouping info for each exon skipping group (sharing same donor).

-o format:
chrom   chromStart  chromEnd    name    scroe   strand
str     int         int         str     int     +/-
-o format (continue):
thickStart  thickEnd    itemRgb blockCount  blockSizes  blockStarts
int         int         255,0,0 int         [int]      [int]
-o format (continue):
sup_read    total_junc_read junc_pos
int         int             pos

-g format:
name    juncs
str     pos,pos...

Created on Wed Sep 25 10:35:15 2013
Modify date: 131002

@author: yansy
"""

import sys
import argparse
sys.path.append("Modules_py27")
from genestructure import Position, Bed12


class ExonSkip(object):
    "exon skipping info generated by scan_exon_skipping.py"
    def __init__(self, line):
        self.record = line.strip().split("\t")
        for i in range(4,7):
            self.record[i] = int(self.record[i])
        (internalExon, self.gene, self.juncPos, self.strand, 
         self.supRead, self.unSupRead_5, self.unSupRead_3, self.exonId_5,
         self.exonId_3) = self.record
        self.juncPos = Position(self.juncPos)
        self.exonSkipped = [Position(pos) for pos in internalExon.split(",")]
        
        
def skips_is_consist(skips):
    "check if strand and unSupRead_5 are consistent, return True or False"
    strand = skips[0].strand
    unsup = skips[0].unSupRead_5
    for skip in skips:
        if skip.strand != strand or skip.unSupRead_5 != unsup:
            return False
    return True

def cal_freq(skips, fout, flog):
    """
    calculate exon skipping frequency from skips, output result to fout, 
    output grouping information to flog
    """
    juncReads = skips[0].unSupRead_5
    for skip in skips:
        juncReads += skip.supRead
    for skip in skips:
        bed = Bed12()
        bed.chrom = skip.juncPos.chrom
        bed.chromStart = bed.thickStart = skip.exonSkipped[0].chromStart
        bed.chromEnd = bed.thickEnd = skip.exonSkipped[-1].chromEnd
        bed.name = "%s_%s_%s" % (skip.gene, skip.exonId_5, skip.exonId_3)
        bed.score = int(1000 * skip.supRead / juncReads)
        bed.strand = skip.strand
        bed.itemRgb = "255,0,0"
        bed.blockCount = len(skip.exonSkipped)
        bed.blockSizes = [pos.chromEnd-pos.chromStart for pos in skip.exonSkipped]
        bed.blockStarts = [pos.chromStart-bed.chromStart for pos in skip.exonSkipped]
        print >> fout, "%s\t%d\t%d\t%d\t%d\t%s" % (repr(bed), skip.supRead, skip.unSupRead_5,
                                            skip.unSupRead_3, juncReads, repr(skip.juncPos))
    print >> flog, "%s\t%s" % (skips[0].gene, 
    ",".join([repr(skip.juncPos) for skip in skips]))

def main(fin, fout, flog):
    all_skips = {}
    fin.readline()
    for line in fin:
        skip = ExonSkip(line)
        chrom = skip.juncPos.chrom
        donor = skip.juncPos.chromStart if skip.strand == "+" \
                                        else skip.juncPos.chromEnd
        name = skip.gene
        if (chrom, donor, name) in all_skips:
            all_skips[(chrom,donor, name)].append(skip)
        else:
            all_skips[(chrom,donor, name)] = [skip]
    fin.close()
    
    print >> fout, "#score is the exon skipping frequency *1000"
    print >> fout, "#"+"\t".join(["chrom", "chromStart", "chromEnd", "name",
                                  "score", "strand", "thickStart", "thickEnd", 
                                  "itemRgb", "blockCount", "blockSizes", 
                                  "blockStarts", "sup_read", "unSupRead_5","unSupRead_3",
                                  "total_junc_read", "junc_pos"])
    
    for (chrom, donor, name) in all_skips:
        skips = all_skips[(chrom, donor, name)]
        if skips_is_consist(skips):
            cal_freq(skips, fout, flog)
        else:
            print >> sys.stderr, (("Inconsistent found at %s, donor at %d "
            "junctions involved: %s") % (chrom, donor, 
            ",".join([repr(skip.juncPos) for skip in skips])))
    fout.close()
    flog.close()
        

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("-i", help=(".exon_skipping file genereated by "
                                    "scan_exon_skipping.py"))
    parser.add_argument("-o", help=("Bed12 format documenting "
                                    "exon skipping events"))
    parser.add_argument("-g", help="grouping info")
    args = parser.parse_args()
    fin = open(args.i, "r")
    fout = open(args.o, "w")
    flog = open(args.g, "w")
    
    main(fin=fin, fout=fout, flog=flog)
